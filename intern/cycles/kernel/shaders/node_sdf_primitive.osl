/*
 * Copyright 2011-2021 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ee the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * SDF Functions based on:
 *
 * - https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
 * - http://mercury.sexy/hg_sdf/
 */

#include "node_hash.h"
#include "stdcycles.h"
#include "vector2.h"
#include "vector4.h"
#include "node_sdf_util.h"

vector2 vec3_to_vec2(point p){
	return vector2(p[0], p[1]);
}

shader node_sdf_primitives(int use_mapping = 0,
                           matrix mapping = matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                           point VectorIn = 0.0,
                           float Size = 1.0,
                           int Sides = 3,
                           float Thickness = 0.0,
                           float Value1 = 1.0,
                           float Value2 = 1.0,
                           float Value3 = 1.0,
                           float Value4 = 1.0,
                           point Point1 = 0.0,
                           point Point2 = 0.0,
                           point Point3 = 0.0,
                           float Angle1 = 0.0,
                           float Angle2 = 0.0,

                           string mode = "",
                           int invert = 0,
                           output float Distance = 0.0)
{
  point p = VectorIn;

  if (use_mapping) {
    p = transform(mapping, p);
  }

  float ret = 0.0;
  float s = Size;
  if (s != 0.0) {
    if (mode == "sphere") {
      ret = sdf_3d_sphere(p, s);
    }
    else if (mode == "hex_prism") {
      ret = sdf_3d_hex_prism(p, point(Value1,Value2,Value3));
    }
    else if (mode == "box") {
      ret = sdf_3d_box(p, point(Value1,Value2,Value3));
    }
    else if (mode == "torus") {
      ret = sdf_3d_torus(p, vector2(Value1, Value2));
    }
    else if (mode == "cone") {
      ret = sdf_3d_cone(p, Angle1);
    }
    else if (mode == "cylinder") {
      ret = sdf_3d_cylinder(p, Point1);
    }
    else if (mode == "capsule") {
      ret = sdf_3d_capsule(p, Point1, Point2);
    }
    else if (mode == "octahedron") {
      ret = sdf_3d_octahedron(p);
    }
    else if (mode == "circle_2d") {
      ret = sdf_2d_circle(vec3_to_vec2(p), s);
    }
    else if (mode == "box_2d") {
      ret = sdf_2d_box(vec3_to_vec2(p), vector2(Value1, Value2));
    }
    else if (mode == "rhombus_2d") {
      ret = sdf_2d_rhombus(vec3_to_vec2(p), vector2(Value1, Value2));
    }
    else if (mode == "triangle_2d") {
      ret = sdf_2d_triangle(vec3_to_vec2(p), s);
    }
    else if (mode == "line_2d") {
      ret = sdf_2d_line(vec3_to_vec2(p), vec3_to_vec2(Point1), vec3_to_vec2(Point2));
    }
    else if (mode == "star_2d") {
      ret = sdf_2d_star(vec3_to_vec2(p), Value1, Sides, Value2);
    }
    else if (mode == "hexagon_2d") {
      ret = sdf_2d_hexagon(vec3_to_vec2(p), s);
    }
    else {
      ret = 0.0;
    }
    ret = sdf_alteration(ret, Size, Value4, Thickness);
    if (invert) {
      ret = -ret;
    }
  }
  else {
    ret = 0.0;
  }
  Distance = ret;
}
